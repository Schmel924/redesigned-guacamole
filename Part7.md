# Первый рефактор, наканец та!

Пошукав по сети я понял что без векторов в спортивном симуляторе никуда, а ни в луа ни в лаве встроенной библиотеки нет.  

###### Будем писать свою!

Что нам понадобится (уже понадобилось): нормализация, длина (ака расстояние до), умножение на скаляр, да и умножение на вектор до кучи.  
Пока не буду выебываться и писать ООП, хватит и  того что теперь каждый объект в игре перерабатывать.
```
function mag (v)
	return math.sqrt(v.x^2 + v.y^2)
end

function norm (v)
	local m = mag (v)
	if (m ~= 0) v.x=v.x/m v.y=v.y/m end 
end

function dist (s,f)
	local v = {}
	v.x = f.x - s.x
	v.y = f.y - s.y
	return mag (v)
end

function dir (s,f)
	local v = {}
	v.x = f.x - s.x
	v.y = f.y - s.y
	return norm (v)
end

function scale (v,s)
	v.x=v.x*s
	v.y=v.y*s
end

function vector.dot(s,f)
    return s.x * f.x + s.y * f.y
end
```
Таак, везде простая математика. s - f start - finish, не считая одного случая когда s - scale.  
Положим это в отдельный файлик vectars.lua (cпециально с ашипкой, чтобы никто не подумал что библиотека хорошо написана), и реквайрим его.

##### Не компилируется.  
Ну конечно, я же это скопировал с всяких левых сайтов и не исправил кучу ошибок. 'vector.' в названии последней функции лишний. А в каждом 'if' обязан быть 'then'
 
### А теперь самое веселое. 

Проходимся по всему проекту и меняем х и у на v. И нигде ничего не пропускаем.

Таак 'GetVector' - переделываем, хотя во что... Где я её использовал?

Puck in goal - здесь используется Puck.x что я и планирую исправить, помечаем, еще вернемся

Score - тут ничего

DrawPuck - тоже Puck.x

PuckDirect - вот отличный кандидат на замену!

ResetPuck  
Вот здесь и прописана структура шайбочки, тут и начнем как следует
```
    Puck = {radius = 20 , color = {0,0,0}}
    local c = {x = RinkX/2, y = RinkY/2}
    local d = {x = love.math.random( -500, 500 ), y = love.math.random( -500, 500 )}
    local dir  = norm (d) --  PuckDirect()
    Puck.c = c
    Puck.d = d
    Puck.dir = dir
```
С - соординаты, d - ускорение, dir - направление (нормаль от ускорения). Очевидно же.

##### Теперь, с новыми знаниями сверху вниз.
`Puck.x` превращаем в `Puck.c.x`  `Puck.d.y` в `Puck.dy`  
Ухх, UPdatePuck займет время...И тут я сталкиваюсь с тем что мои функции ломают входные переменные. Кажется. Перепишу-ка я их через ретурны все.

love.load - опять пусто

Love.update...хмм, а вот и первое испытание для нового синтаксиса. 
```
local x,y = love.mouse.getPosition()
        Puck.dx = x - Puck.x
        Puck.dy = y - Puck.y
```
МОжем заменить на... на... блин, нет у меня такой функции!
```
function path (s,f)
	local v = {}
	v.x = f.x-s.x
	v.y = f.y-s.x
	return v
end
```
Получился GetVector...Когда найду куда его использовал, заменю, а пока
```
local x,y = love.mouse.getPosition()
      local v = {x,y}
      Puck.d = path(Puck.c,v)
```
Если бы я знал как получать из getPosition сразу нужную таблицу...

love.draw просто вызывает самоотрисовки. И собсна всё, с мэйном покончено. Переходим к DAMAN

### Мужики

Вот здесь много переменных. И векторных выичислений.  
O, а первым делом GetVector проявился. Переживал за его судьбу больше чем за свою. ` Puck.d = path (pl.с,LeftGate.center)` Красиво же, едрен батон

ФФух, вроде всё. Проверяю и молюсь Страуструпу

###### Ххаха, если бы
Если я правильно понимаю луа не любит когда обращаюся к элементу таблицы не создав таблицу. Т.е. Напрямую Player.c.x. Ща исправим.

Но и это еще не всё. Знаете какая буква на русском и английском языках находится на одной кнопке клавиатуры но имеет разные аскии коды для компилятора? Верно, та которой я обозначил соординаты...

Окей, при запуске шайба и оба фигуриста улетают в одно и тоже место и застревают в крае поля. Что значит, где-то в упдейте есть просчет.

Окей, первый момент. Походу в нормализации из всякого синтаксического бреда я нормализовал и тот вектор который ненадо. Исправлено.
```
local z = {x=0,y=o}
	if (m ~= 0) then z.x=v.x/m z.y=v.y/m end 
	return z
```

Но возникла серъезная проблема. Когда я нажимаю мышкой всё вылетает с тем что дескать х - это несуществующая переменная. 

Аха, кажется нашел проблему.
```
       x, y = love.mouse.getPosition()
         local v = {x,y}
```
В данной ситуации выходит что таблица V = {1=x,2=y}, а мы хотим V= {x=x, y=y}!

УРАСЬ!

Теперь следующая проблема. Хоккеист хватает шайбу и прилепляется к ней...и начинает за ней ездить. Очень Очень медленно.

Аха, это потому что при попытке поймать шайбу я не делаю проверку на дальность, а просто на то есть ли расстояние между ними. 
А вот с запуском шайбы большие проблемы. Почему, когда хоккеист назначает шайбе координаты на 25 левее себя, он тут же туда за ней летит? Может быть потому что таблицы в Луа передаются адресно?   ` Puck.c = pl.c` и теперь это одна таблица?  
Cудя по книге pil так и есть.
Теперь то что? Как скопировать таблицу в таблицу? Пока никак, вернемся к последовательному копированию элементов.

На этом всё. Функционал на сегодня восстановлен. 