# State machine!

Как всегда напишу  свою, а читатель может плеваться от качества.

Я так думаю чистую, универсальную библиотеку писать не буду (пока что), а буду реализоваывать автомат там где в голву взбредет. Вот, для начала мне нужны автоматы для игроков, а для статуса игры потом как нибудь.

#### Что должен мочь хоккеист?

Я разве еще не задавался этим вопросом?  
Ловить шайбу, пинать шайбу.   
Пинать легко, есть шайба - не вижу препятствий.  
Вопрос в ловить!

## Для чего я писал все эти вектора?

Пусть хоккеист ищет глазами шайбу, и бежит к ней сам, а не ждет.  А вектора помогут вычислить все необходимое.
```
p.d = scale(dir (p.c,Puck.c),p.speed)
CatchPuck (p)
```
это у нас в упдейтПлеерс будет. Где p это каждый отдельный игрочок, а спиид - это новое магическое число.

Ну и меняем PlayerA.Puck на что нить вроде PlayerA.state  
Который я хочу менять в зависимости от ситуации на всем поле.   
Но мне не хочется в цикле каждого игрока проверять всех остальных игроков на вопрос у кого шайба?. А то выйдет как в Crusader Kings, когда все греки в какой-то момент решили что пора рекурсивно проверить нельзя ли кого-нибудь из соседов кастрировать. А выход из рекурсии ЗАБЫЛИ,

#### Так что делаем сразу второй уровень. __МЕТА-СТЕЙТ-МАШИНЫ.__
```
Gamestate = "draw"
```
Просто глобалка, которую все видят и некоторые меняют. Что в этом плохого?

Если кто-то поймал шайбу 
```
pl.state = "attack" Gamestate = "attack"
```
Пока шайба ничья
```
pl.state = "hunt" Gamestate = "draw"
```
Пока шайба летит
```
pl.state = "wait" Gamestate = "shot"
```
В ResetPuck() очевидно вставляем Gamestate = "draw" и пожалуй в цикле всем игрокам вернем дефолт "hunt", чтобы бегали.

##### Всё работает, игроки даже бегают по полю.

Удивительно. Пожалуй коммит, пока оно работает.

Теперь переписываем UpdatePlayers целиком, чтобы автомат учитывать
```
for i,p in ipairs(Players) do
   
    if (p.state ~= "wait") then
    p.c.x = p.c.x + p.d.x*dt
    p.c.y = p.c.y + p.d.y*dt
    end

    if p.state == "attack" then 
        LaunchPuck (p)
        p.state = "wait"
    end

    if p.state == "hunt" then
    p.d = scale(dir (p.c,Puck.c),p.speed)
        if CatchPuck (p) then
        p.state = "attack" Gamestate = "attack"
        end
    end

end
```
 Первый иф - двигаться игроку или нет. Второй - если поймал - "кидай", Третий - "Лови." 

 Переправил CatchPuck так чтобы он возвращал булевую. Лишь бы мест где происходит изменения глобального State было поменьше.


 Да, и запуск шайбы я переписал чтобы сила полета шайбы не зависела от дальности ворот

```
Puck.d = scale(dir (pl.c,LeftGate.center),pl.force)
```

 Теперь я хочу чтобы между пойманием шайбы и швырянием прошла ощутимая секунда для зрителя. Как это реализовать?
Есть какая то функция love.timer.getTime
Попробуем. Но сначала еще один бекап-коммит

Как выяснилось легко

`p.time = love.timer.getTime()`    а после как словил шайбу проверяем `love.timer.getTime() - p.time > 1`
Работает. 

Но вот что выяснилось: после поймания шайбы хоккеист продолжает ехать в направлении её последних координат. Добавим ему  `p.d = scale (p.d,0)`

Теперь я хочу (начинаю повторяться) чтобы игроки взаимодействовали, и вели себя так будто пытаются играть против друг друга. А это значит переписывать их структуру. ДА и делить на зеленых и синих. Точно не сегодня.

Из приятного: я так всё абстрактнул в мэйне, что не считая строчки вставленной в ResetPuck мне ничего не пришлось там трогать, а все изменения были в файле 'daman.lua'. Это классно.