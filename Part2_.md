# Вторая часть
Я решил что достаточно, можно отделить этап разработки, теперь мы будем копать в другом месте.

## Преамбула  
Накостыляв на предыдущем этапе говнофизику, я понял что хочу попоробовать настоящий PHYSX

Для того чтобы не сломать имеющееся создам отдельную [гит ветку](https://github.com/Schmel924/redesigned-guacamole/tree/bump) в которой вся эта попытка и будет контенирована

Для контроля будет использоваться попрежнему библиотека [lovebird](https://github.com/rxi/lovebird)

Для самой физики можно взять встроенный в лове2д движок, но мы простой путь не выбираем, мы берем другую библиотеку.

Думал я долго, но плюсы и минусы не сравнивал, решение не принимал, в итоге взял [bump](https://github.com/kikito/bump.lua).
Надеюсь не нарушил лицензию MIT скопировав библиотечку себе в репозиторий. Если что, извинюсь и заменю на ссылку.

## Этап первый  
Читаем описание библиотеки. Нужно создать ZA WARUDO, добавить в него объекты, и радоваться?
``` lua
world = bump.newWorld(64)
world:add(Player,x,y,w,h)
???
А где профит?
```

### Этап 1.5 Понимаем описание библиотеки
Чтобы создать объект внутри мира, нужно иметь некий объект (таблицу), который скормить функции `world:add` вместе с координатами и габаритами.
Именно по уникальному идентификатору таблицы (объекта), переданного в функцию и будет производится дальнейшая работа с объектом.

### Разбираем описание библиотеки
Вот тут я не выдержал, подключил lovebird, добавил в генерацию игроков выдуманное имя, пока еще случайным образом, и начал следить за происходящим.
Но то что оказалось внутри таблицы World меня поразило, какие то строки, столбцы, ссылки на другие таблицы. Мне было ничего не понятно. Можно было конечно открыть сырцы и разбираться, но я пошел другим путем. Заставил библиотеку bump писать в lovebird о том какие таблицы она создает, и уверился в том что они совпадают с идентификаторами таблиц в массиве Players.

#### интерлюдия
А еще недавно удостоверился через онлайн интерпретатор, что таблицы в луа передаются по адресу, и если внутри функции в таблице что-то изменить то и вне функции эти изменнеия будут видны. Так что просто сказал, это гребаная магия, успокойся, так и должно работать

## Учимся пользоваться библиотекой.
Пример в описании очень здоровский: "дайте одному прямоугольнику через внутренние фнукции библиотеки задание пролететь сквозь другой прямоугольник, и получите collision"
Вопрос: что делать если у меня координаты, скорость и вектора все вне библиотеки, как их туда вносить?

### Какой он хитрый
```
The usual way you would use move is: calculate a "desirable" `goalX, goalY` point for an item (maybe using its velocity), pass it to move, and then use `actualX, actualY` as the real "updates"
```
Ну то есть, вся моя математика идет отдельно, её расчет я передаю внутрь функции `world:move`, и он мне отвечает "Вышло" или "Не вышло".
Знаете в скольких местах у меня сейчас `p.c.x = p.c.x + p.d.x*dt`? Мне кажется что в четырех... Пора это убирать в готовую функцию, да?
```lua
function update_coord(dt, p)
    local goalX = p.c.x + p.d.x*dt
    local goalY = p.c.y + p.d.y*dt
    local actualX, actualY, cols, len = world:move(p, goalX, goalY)
    p.c.x = actualX 
    p.c.y = actualY
    for i = 1, len do lovebird.print(p.name .. "==" .. tostring(cols[i].other)) end
end    
```
и после того как я не забыл закрыть цикл вывода в lovebird отладочной информации, оно даже заработало!
### правда, возникла пара проблем.
Ноутбук внезапно стал издавать звуки напоминающие вентилятор, ну то есть _возникла нагрузка_, да и фпс просел с 500 где-то до 300. 
Из чего я лично сделал вывод, что возможно к финалу мы будем даже ебаться с оптимизацией.
Сейчас у меня только одно желание, убрать ручную функцию bumping, найти в библиотеке, как сделать из каждого столкновения конфетку, да и выспаться.

